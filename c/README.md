+ 关键字`static`声明的函数具有静态链接, 只能在当前文件中使用
+ 关键字`extern`声明的变量表示在其他文件定义

+ C命令行库：linenoise

+ 闭包
    + 搜索“闭包转换 closure conversion”和“Lambda提升 lambda lifting”就可以开始探索黑客们设计了各种各样的方式来编译闭包
    + Lua是怎么处理闭包的呢？上值upvalue
      + upvalue上值指的是一个闭包函数中的局部变量.每个闭包都维护一个上值数组，每个上值对应闭包使用的外围局部变量
      + 开放上值来表示一个指向仍在栈中的局部变量的上值。当变量移动到堆中时，我们就关闭上值，而结果自然就是一个关闭的上值
    
    + 闭包捕获的是值还是变量？应该是变量

## Introduction

首先一个问题就是"多态".

一方面, Lox本身就是动态语言, 它是怎么让一个名称可以维护不同类型的值的呢？这很像union, 是的, 更具体的说, clox使用了tagged union/type punning技术, 结构体的第一个属性是一个枚举, 表示这个结构体维护的值的类型, 具体的值有结构体中的一个union存储.

另一方面, Lox解释器内部一定使用了"独属于它的类型"(不是C的类型, 也不是Lox的类型), 就像Python的object, 是所有类的基类, 那么在C语言中怎么实现"派生"呢？

其实和上面很像, 把基类作为结构体的第一个属性即可(又到了踩继承捧组合的时间了), 基类内部有枚举属性表示派生类类型.

接下来要的问题是要分区两个概念
+ 编译期的块
+ 运行时的栈

clox是将Lox代码编译成字节码, 然后在自己的虚拟机中运行这些字节码

这里的字节码包括指令和数值, 这些分别存在两个字节数组中, 有个比较容易的抽象就是对不同函数可以放在不同的块里, 确实是这样的, 不同的函数之间只有调用, 而不会使用到对方的指令.

然后在运行时, clox的虚拟机是一个基于堆栈的虚拟机, 有一个运行时的栈, 这个栈是所有的函数共享的, 所有我们在代码中的调用栈结构体中有一个指向栈的指针, 所有的调用栈其实指向的是同一个栈.

## GC

+ 关于GC的三色标记, 在这里, 只要遇到就会标记成黑色, 但是会将其在第一次标记成黑色时放进灰色栈中, 然后只在灰色栈中找继续处理. 
+ 指标：
  + 吞吐量: 运行时间占总时间(还包括GC)的占比.
  + 延迟: 当垃圾回收发生时，用户的程序完全暂停的最长连续时间块.
  
  我们希望GC运行得足够频繁，以最小化延迟，但又不能太频繁，以维持良好的吞吐量。

+ GC算法
  + 标记-清除
  + 其他：引用计数、Cheney算法或Lisp 2标记-压缩算法

+ GC方式
  + stop-the-world GC
  + 增量式垃圾回收器

+ 分代垃圾回收: 
  >研究人员有一种代际假说, 即早夭, 大部分对象寿命很短, 但是一旦他们超过一定的年龄, 他们就会存货很长时间.

  先将对象放在一个小的、频繁GC的nursery托儿所, 一旦对象在几代(几次GC)都没有被清除, 则放在一个更大的、GC不频繁的区域.
